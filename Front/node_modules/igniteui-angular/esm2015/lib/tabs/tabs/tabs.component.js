import { AnimationBuilder } from '@angular/animations';
import { Component, HostBinding, Input, NgZone, ViewChild } from '@angular/core';
import { getResizeObserver, mkenum } from '../../core/utils';
import { IgxTabsBase } from '../tabs.base';
import { IgxTabsDirective } from '../tabs.directive';
export const IgxTabsAlignment = mkenum({
    start: 'start',
    end: 'end',
    center: 'center',
    justify: 'justify'
});
/** @hidden */
var TabScrollButtonStyle;
(function (TabScrollButtonStyle) {
    TabScrollButtonStyle["Visible"] = "visible";
    TabScrollButtonStyle["Hidden"] = "hidden";
    TabScrollButtonStyle["NotDisplayed"] = "not_displayed";
})(TabScrollButtonStyle || (TabScrollButtonStyle = {}));
/** @hidden */
let NEXT_TAB_ID = 0;
/**
 * Tabs component is used to organize or switch between similar data sets.
 *
 * @igxModule IgxTabsModule
 *
 * @igxTheme igx-tabs-theme
 *
 * @igxKeywords tabs
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Tabs component places tabs at the top and allows for scrolling when there are multiple tab items on the screen.
 *
 * @example
 * ```html
 * <igx-tabs>
 *     <igx-tab-item>
 *         <igx-tab-header>
 *             <igx-icon igxTabHeaderIcon>folder</igx-icon>
 *             <span igxTabHeaderLabel>Tab 1</span>
 *         </igx-tab-header>
 *         <igx-tab-content>
 *             Content 1
 *         </igx-tab-content>
 *     </igx-tab-item>
 *     ...
 * </igx-tabs>
 * ```
 */
export class IgxTabsComponent extends IgxTabsDirective {
    constructor(builder, ngZone) {
        super(builder);
        this.ngZone = ngZone;
        /** @hidden */
        this.defaultClass = true;
        /**  @hidden */
        this.offset = 0;
        /** @hidden */
        this.componentName = 'igx-tabs';
        this._tabAlignment = 'start';
    }
    /**
     * An @Input property which determines the tab alignment. Defaults to `start`.
     */
    get tabAlignment() {
        return this._tabAlignment;
    }
    ;
    set tabAlignment(value) {
        this._tabAlignment = value;
        requestAnimationFrame(() => {
            this.updateScrollButtons();
            this.realignSelectedIndicator();
        });
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver = new (getResizeObserver())(() => {
                this.updateScrollButtons();
                this.realignSelectedIndicator();
            });
            this._resizeObserver.observe(this.headerContainer.nativeElement);
            this._resizeObserver.observe(this.viewPort.nativeElement);
        });
    }
    /** @hidden @internal */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.ngZone.runOutsideAngular(() => {
            var _a;
            (_a = this._resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        });
    }
    /** @hidden */
    scrollLeft() {
        this.scroll(false);
    }
    /** @hidden */
    scrollRight() {
        this.scroll(true);
    }
    /** @hidden */
    realignSelectedIndicator() {
        if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
            const header = this.items.get(this.selectedIndex).headerComponent.nativeElement;
            this.alignSelectedIndicator(header, 0);
        }
    }
    /** @hidden */
    resolveHeaderScrollClasses() {
        return {
            'igx-tabs__header-scroll--start': this.tabAlignment === 'start',
            'igx-tabs__header-scroll--end': this.tabAlignment === 'end',
            'igx-tabs__header-scroll--center': this.tabAlignment === 'center',
            'igx-tabs__header-scroll--justify': this.tabAlignment === 'justify',
        };
    }
    /** @hidden */
    scrollTabHeaderIntoView() {
        if (this.selectedIndex >= 0) {
            const tabItems = this.items.toArray();
            const tabHeaderNativeElement = tabItems[this.selectedIndex].headerComponent.nativeElement;
            // Scroll left if there is need
            if (tabHeaderNativeElement.offsetLeft < this.offset) {
                this.scrollElement(tabHeaderNativeElement, false);
            }
            // Scroll right if there is need
            const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            const delta = (tabHeaderNativeElement.offsetLeft + tabHeaderNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabHeaderNativeElement, true);
            }
            this.alignSelectedIndicator(tabHeaderNativeElement);
        }
        else {
            this.hideSelectedIndicator();
        }
    }
    /** @hidden */
    getNextTabId() {
        return NEXT_TAB_ID++;
    }
    /** @hidden */
    onItemChanges() {
        super.onItemChanges();
        Promise.resolve().then(() => {
            this.updateScrollButtons();
        });
    }
    alignSelectedIndicator(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideSelectedIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
    scroll(scrollRight) {
        const tabsArray = this.items.toArray();
        for (const tab of tabsArray) {
            const element = tab.headerComponent.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    scrollElement(element, scrollRight) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsWrapper.nativeElement.style.transform = `translate(${-this.offset}px)`;
        this.updateScrollButtons();
    }
    updateScrollButtons() {
        const itemsContainerWidth = this.getTabItemsContainerWidth();
        const leftButtonStyle = this.resolveLeftScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.leftButton.nativeElement, leftButtonStyle);
        const rightButtonStyle = this.resolveRightScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.rightButton.nativeElement, rightButtonStyle);
    }
    setScrollButtonStyle(button, buttonStyle) {
        if (buttonStyle === TabScrollButtonStyle.Visible) {
            button.style.visibility = 'visible';
            button.style.display = '';
        }
        else if (buttonStyle === TabScrollButtonStyle.Hidden) {
            button.style.visibility = 'hidden';
            button.style.display = '';
        }
        else if (buttonStyle === TabScrollButtonStyle.NotDisplayed) {
            button.style.display = 'none';
        }
    }
    resolveLeftScrollButtonStyle(itemsContainerWidth) {
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return TabScrollButtonStyle.NotDisplayed;
            }
            return TabScrollButtonStyle.Hidden;
        }
        else {
            return TabScrollButtonStyle.Visible;
        }
    }
    resolveRightScrollButtonStyle(itemsContainerWidth) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return TabScrollButtonStyle.NotDisplayed;
        }
        if (itemsContainerWidth > total) {
            return TabScrollButtonStyle.Visible;
        }
        else {
            return TabScrollButtonStyle.Hidden;
        }
    }
    getTabItemsContainerWidth() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 1];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        return itemsContainerWidth;
    }
}
IgxTabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-tabs',
                template: "<div #headerContainer class=\"igx-tabs__header\">\r\n    <button\r\n        #leftButton\r\n        igxButton=\"icon\"\r\n        igxRipple\r\n        class=\"igx-tabs__header-button\"\r\n        (click)=\"scrollLeft()\"\r\n    >\r\n        <igx-icon>navigate_before</igx-icon>\r\n    </button>\r\n    <div #viewPort class=\"igx-tabs__header-content\">\r\n        <div\r\n            #itemsWrapper\r\n            class=\"igx-tabs__header-wrapper\"            \r\n            role=\"tablist\"\r\n        >\r\n            <div \r\n                #itemsContainer\r\n                class=\"igx-tabs__header-scroll\"\r\n                [ngClass]=\"resolveHeaderScrollClasses()\"\r\n            >\r\n                <ng-container *ngFor=\"let tab of items; let i = index\">\r\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\r\n                </ng-container>\r\n            </div>\r\n            <div\r\n                #selectedIndicator\r\n                *ngIf=\"items.length > 0\"\r\n                class=\"igx-tabs__header-active-indicator\"\r\n            >\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <button\r\n        #rightButton\r\n        igxButton=\"icon\"\r\n        igxRipple\r\n        class=\"igx-tabs__header-button\"\r\n        (click)=\"scrollRight()\"\r\n    >\r\n        <igx-icon>navigate_next</igx-icon>\r\n    </button>\r\n</div>\r\n<div class=\"igx-tabs__panels\">\r\n    <ng-container *ngFor=\"let tab of items; let i = index\">\r\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\r\n    </ng-container>\r\n</div>\r\n",
                providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
            },] }
];
IgxTabsComponent.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: NgZone }
];
IgxTabsComponent.propDecorators = {
    tabAlignment: [{ type: Input }],
    headerContainer: [{ type: ViewChild, args: ['headerContainer', { static: true },] }],
    viewPort: [{ type: ViewChild, args: ['viewPort', { static: true },] }],
    itemsWrapper: [{ type: ViewChild, args: ['itemsWrapper', { static: true },] }],
    itemsContainer: [{ type: ViewChild, args: ['itemsContainer', { static: true },] }],
    selectedIndicator: [{ type: ViewChild, args: ['selectedIndicator',] }],
    leftButton: [{ type: ViewChild, args: ['leftButton',] }],
    rightButton: [{ type: ViewChild, args: ['rightButton',] }],
    defaultClass: [{ type: HostBinding, args: ['class.igx-tabs',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdGFicy90YWJzL3RhYnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBaUIsU0FBUyxFQUFjLFdBQVcsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFhLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN2SCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDN0QsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVyRCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUM7SUFDbkMsS0FBSyxFQUFFLE9BQU87SUFDZCxHQUFHLEVBQUUsS0FBSztJQUNWLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLE9BQU8sRUFBRSxTQUFTO0NBQ3JCLENBQUMsQ0FBQztBQUVILGNBQWM7QUFDZCxJQUFLLG9CQUlKO0FBSkQsV0FBSyxvQkFBb0I7SUFDckIsMkNBQW1CLENBQUE7SUFDbkIseUNBQWlCLENBQUE7SUFDakIsc0RBQThCLENBQUE7QUFDbEMsQ0FBQyxFQUpJLG9CQUFvQixLQUFwQixvQkFBb0IsUUFJeEI7QUFJRCxjQUFjO0FBQ2QsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBRXBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCRztBQU9ILE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxnQkFBZ0I7SUEyRGxELFlBQVksT0FBeUIsRUFBVSxNQUFjO1FBQ3pELEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUQ0QixX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RTt1QkFJN0MsU0FBUyxTQUFDLFVBQVUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7MkJBSXRDLFNBQVMsU0FBQyxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFOzZCQUkxQyxTQUFTLFNBQUMsZ0JBQWdCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dDQUk1QyxTQUFTLFNBQUMsbUJBQW1CO3lCQUk3QixTQUFTLFNBQUMsWUFBWTswQkFJdEIsU0FBUyxTQUFDLGFBQWE7MkJBSXZCLFdBQVcsU0FBQyxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbmltYXRpb25CdWlsZGVyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGdldFJlc2l6ZU9ic2VydmVyLCBta2VudW0gfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcclxuaW1wb3J0IHsgSWd4VGFic0Jhc2UgfSBmcm9tICcuLi90YWJzLmJhc2UnO1xyXG5pbXBvcnQgeyBJZ3hUYWJzRGlyZWN0aXZlIH0gZnJvbSAnLi4vdGFicy5kaXJlY3RpdmUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IElneFRhYnNBbGlnbm1lbnQgPSBta2VudW0oe1xyXG4gICAgc3RhcnQ6ICdzdGFydCcsXHJcbiAgICBlbmQ6ICdlbmQnLFxyXG4gICAgY2VudGVyOiAnY2VudGVyJyxcclxuICAgIGp1c3RpZnk6ICdqdXN0aWZ5J1xyXG59KTtcclxuXHJcbi8qKiBAaGlkZGVuICovXHJcbmVudW0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUge1xyXG4gICAgVmlzaWJsZSA9ICd2aXNpYmxlJyxcclxuICAgIEhpZGRlbiA9ICdoaWRkZW4nLFxyXG4gICAgTm90RGlzcGxheWVkID0gJ25vdF9kaXNwbGF5ZWQnXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIElneFRhYnNBbGlnbm1lbnQgPSAodHlwZW9mIElneFRhYnNBbGlnbm1lbnQpW2tleW9mIHR5cGVvZiBJZ3hUYWJzQWxpZ25tZW50XTtcclxuXHJcbi8qKiBAaGlkZGVuICovXHJcbmxldCBORVhUX1RBQl9JRCA9IDA7XHJcblxyXG4vKipcclxuICogVGFicyBjb21wb25lbnQgaXMgdXNlZCB0byBvcmdhbml6ZSBvciBzd2l0Y2ggYmV0d2VlbiBzaW1pbGFyIGRhdGEgc2V0cy5cclxuICpcclxuICogQGlneE1vZHVsZSBJZ3hUYWJzTW9kdWxlXHJcbiAqXHJcbiAqIEBpZ3hUaGVtZSBpZ3gtdGFicy10aGVtZVxyXG4gKlxyXG4gKiBAaWd4S2V5d29yZHMgdGFic1xyXG4gKlxyXG4gKiBAaWd4R3JvdXAgTGF5b3V0c1xyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIFRhYnMgY29tcG9uZW50IHBsYWNlcyB0YWJzIGF0IHRoZSB0b3AgYW5kIGFsbG93cyBmb3Igc2Nyb2xsaW5nIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHRhYiBpdGVtcyBvbiB0aGUgc2NyZWVuLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBodG1sXHJcbiAqIDxpZ3gtdGFicz5cclxuICogICAgIDxpZ3gtdGFiLWl0ZW0+XHJcbiAqICAgICAgICAgPGlneC10YWItaGVhZGVyPlxyXG4gKiAgICAgICAgICAgICA8aWd4LWljb24gaWd4VGFiSGVhZGVySWNvbj5mb2xkZXI8L2lneC1pY29uPlxyXG4gKiAgICAgICAgICAgICA8c3BhbiBpZ3hUYWJIZWFkZXJMYWJlbD5UYWIgMTwvc3Bhbj5cclxuICogICAgICAgICA8L2lneC10YWItaGVhZGVyPlxyXG4gKiAgICAgICAgIDxpZ3gtdGFiLWNvbnRlbnQ+XHJcbiAqICAgICAgICAgICAgIENvbnRlbnQgMVxyXG4gKiAgICAgICAgIDwvaWd4LXRhYi1jb250ZW50PlxyXG4gKiAgICAgPC9pZ3gtdGFiLWl0ZW0+XHJcbiAqICAgICAuLi5cclxuICogPC9pZ3gtdGFicz5cclxuICogYGBgXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAnaWd4LXRhYnMnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0YWJzLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogSWd4VGFic0Jhc2UsIHVzZUV4aXN0aW5nOiBJZ3hUYWJzQ29tcG9uZW50IH1dXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgSWd4VGFic0NvbXBvbmVudCBleHRlbmRzIElneFRhYnNEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHdoaWNoIGRldGVybWluZXMgdGhlIHRhYiBhbGlnbm1lbnQuIERlZmF1bHRzIHRvIGBzdGFydGAuXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IHRhYkFsaWdubWVudCgpOiBzdHJpbmcgfCBJZ3hUYWJzQWxpZ25tZW50IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFiQWxpZ25tZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2V0IHRhYkFsaWdubWVudCh2YWx1ZTogc3RyaW5nIHwgSWd4VGFic0FsaWdubWVudCkge1xyXG4gICAgICAgIHRoaXMuX3RhYkFsaWdubWVudCA9IHZhbHVlO1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQnV0dG9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBAVmlld0NoaWxkKCdoZWFkZXJDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxyXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIEBWaWV3Q2hpbGQoJ3ZpZXdQb3J0JywgeyBzdGF0aWM6IHRydWUgfSlcclxuICAgIHB1YmxpYyB2aWV3UG9ydDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIEBWaWV3Q2hpbGQoJ2l0ZW1zV3JhcHBlcicsIHsgc3RhdGljOiB0cnVlIH0pXHJcbiAgICBwdWJsaWMgaXRlbXNXcmFwcGVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcclxuXHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgQFZpZXdDaGlsZCgnaXRlbXNDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxyXG4gICAgcHVibGljIGl0ZW1zQ29udGFpbmVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcclxuXHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0ZWRJbmRpY2F0b3InKVxyXG4gICAgcHVibGljIHNlbGVjdGVkSW5kaWNhdG9yOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcclxuXHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgQFZpZXdDaGlsZCgnbGVmdEJ1dHRvbicpXHJcbiAgICBwdWJsaWMgbGVmdEJ1dHRvbjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIEBWaWV3Q2hpbGQoJ3JpZ2h0QnV0dG9uJylcclxuICAgIHB1YmxpYyByaWdodEJ1dHRvbjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRhYnMnKVxyXG4gICAgcHVibGljIGRlZmF1bHRDbGFzcyA9IHRydWU7XHJcblxyXG4gICAgLyoqICBAaGlkZGVuICovXHJcbiAgICAgcHVibGljIG9mZnNldCA9IDA7XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIHByb3RlY3RlZCBjb21wb25lbnROYW1lID0gJ2lneC10YWJzJztcclxuXHJcbiAgICBwcml2YXRlIF90YWJBbGlnbm1lbnQ6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQgPSAnc3RhcnQnO1xyXG4gICAgcHJpdmF0ZSBfcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXIsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHtcclxuICAgICAgICBzdXBlcihidWlsZGVyKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xyXG5cclxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IChnZXRSZXNpemVPYnNlcnZlcigpKSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjcm9sbEJ1dHRvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhbGlnblNlbGVjdGVkSW5kaWNhdG9yKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuaGVhZGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBwdWJsaWMgc2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbChmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIHB1YmxpYyBzY3JvbGxSaWdodCgpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbCh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgcHVibGljIHJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID49MCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLml0ZW1zLmdldCh0aGlzLnNlbGVjdGVkSW5kZXgpLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLmFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoaGVhZGVyLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gKi9cclxuICAgIHB1YmxpYyByZXNvbHZlSGVhZGVyU2Nyb2xsQ2xhc3NlcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLXN0YXJ0JzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdzdGFydCcsXHJcbiAgICAgICAgICAgICdpZ3gtdGFic19faGVhZGVyLXNjcm9sbC0tZW5kJzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdlbmQnLFxyXG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLWNlbnRlcic6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnY2VudGVyJyxcclxuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1qdXN0aWZ5JzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdqdXN0aWZ5JyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaGlkZGVuICovXHJcbiAgICBwcm90ZWN0ZWQgc2Nyb2xsVGFiSGVhZGVySW50b1ZpZXcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYkl0ZW1zID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQgPSB0YWJJdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgLy8gU2Nyb2xsIGxlZnQgaWYgdGhlcmUgaXMgbmVlZFxyXG4gICAgICAgICAgICBpZiAodGFiSGVhZGVyTmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IDwgdGhpcy5vZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJIZWFkZXJOYXRpdmVFbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNjcm9sbCByaWdodCBpZiB0aGVyZSBpcyBuZWVkXHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXdQb3J0T2Zmc2V0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gKHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdCArIHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgpIC0gKHZpZXdQb3J0T2Zmc2V0V2lkdGggKyB0aGlzLm9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9uc1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWxpZ25TZWxlY3RlZEluZGljYXRvcih0YWJIZWFkZXJOYXRpdmVFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVTZWxlY3RlZEluZGljYXRvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgcHJvdGVjdGVkIGdldE5leHRUYWJJZCgpIHtcclxuICAgICAgICByZXR1cm4gTkVYVF9UQUJfSUQrKztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQGhpZGRlbiAqL1xyXG4gICAgcHJvdGVjdGVkIG9uSXRlbUNoYW5nZXMoKSB7XHJcbiAgICAgICAgc3VwZXIub25JdGVtQ2hhbmdlcygpO1xyXG5cclxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhbGlnblNlbGVjdGVkSW5kaWNhdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkdXJhdGlvbiA9IDAuMyk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kaWNhdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gPiAwID8gYCR7ZHVyYXRpb259c2AgOiAnaW5pdGlhbCc7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke2VsZW1lbnQub2Zmc2V0V2lkdGh9cHhgO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2VsZW1lbnQub2Zmc2V0TGVmdH1weClgO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhpZGVTZWxlY3RlZEluZGljYXRvcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGljYXRvcikge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNjcm9sbChzY3JvbGxSaWdodDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHRhYnNBcnJheSA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGFiIG9mIHRhYnNBcnJheSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGFiLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFdpZHRoICsgZWxlbWVudC5vZmZzZXRMZWZ0ID4gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoICsgdGhpcy5vZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsUmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggKyBlbGVtZW50Lm9mZnNldExlZnQgPj0gdGhpcy5vZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsUmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2Nyb2xsRWxlbWVudChlbGVtZW50OiBhbnksIHNjcm9sbFJpZ2h0OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgdmlld1BvcnRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAoc2Nyb2xsUmlnaHQpID8gZWxlbWVudC5vZmZzZXRXaWR0aCArIGVsZW1lbnQub2Zmc2V0TGVmdCAtIHZpZXdQb3J0V2lkdGggOiBlbGVtZW50Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgdGhpcy5pdGVtc1dyYXBwZXIubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7LXRoaXMub2Zmc2V0fXB4KWA7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVTY3JvbGxCdXR0b25zKCkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1zQ29udGFpbmVyV2lkdGggPSB0aGlzLmdldFRhYkl0ZW1zQ29udGFpbmVyV2lkdGgoKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGVmdEJ1dHRvblN0eWxlID0gdGhpcy5yZXNvbHZlTGVmdFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGgpO1xyXG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsQnV0dG9uU3R5bGUodGhpcy5sZWZ0QnV0dG9uLm5hdGl2ZUVsZW1lbnQsIGxlZnRCdXR0b25TdHlsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJpZ2h0QnV0dG9uU3R5bGUgPSB0aGlzLnJlc29sdmVSaWdodFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGgpO1xyXG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsQnV0dG9uU3R5bGUodGhpcy5yaWdodEJ1dHRvbi5uYXRpdmVFbGVtZW50LCByaWdodEJ1dHRvblN0eWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNldFNjcm9sbEJ1dHRvblN0eWxlKGJ1dHRvbjogSFRNTEVsZW1lbnQsIGJ1dHRvblN0eWxlOiBUYWJTY3JvbGxCdXR0b25TdHlsZSkge1xyXG4gICAgICAgIGlmIChidXR0b25TdHlsZSA9PT0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuVmlzaWJsZSkge1xyXG4gICAgICAgICAgICBidXR0b24uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcclxuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvblN0eWxlID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5IaWRkZW4pIHtcclxuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvblN0eWxlID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5Ob3REaXNwbGF5ZWQpIHtcclxuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJpdmF0ZSByZXNvbHZlTGVmdFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGg6IG51bWJlcik6IFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJDb250YWluZXJXaWR0aCA9IHRoaXMuaGVhZGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcblxyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gRml4IGZvciBJRSAxMSwgYSBkaWZmZXJlbmNlIGlzIGFjY3VtdWxhdGVkIGZyb20gdGhlIHdpZHRocyBjYWxjdWxhdGlvbnMuXHJcbiAgICAgICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoIC0gaGVhZGVyQ29udGFpbmVyV2lkdGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuSGlkZGVuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5WaXNpYmxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc29sdmVSaWdodFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGg6IG51bWJlcik6IFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcclxuICAgICAgICBjb25zdCB2aWV3UG9ydFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lcldpZHRoID0gdGhpcy5oZWFkZXJDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBjb25zdCB0b3RhbCA9IG9mZnNldCArIHZpZXdQb3J0V2lkdGg7XHJcblxyXG4gICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zLlxyXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoIC0gaGVhZGVyQ29udGFpbmVyV2lkdGggPD0gMSAmJiBvZmZzZXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoID4gdG90YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLlZpc2libGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLkhpZGRlbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRUYWJJdGVtc0NvbnRhaW5lcldpZHRoKCkge1xyXG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIGhhY2t5IHdheSB0byBnZXQgdGhlIHdpZHRoIG9mIHRoZSBpdGVtc0NvbnRhaW5lcixcclxuICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIGluY29uc2lzdGVuY3kgaW4gSUUgd2UgY2Fubm90IHVzZSBvZmZzZXRXaWR0aCBvciBzY3JvbGxPZmZzZXQuXHJcbiAgICAgICAgY29uc3QgaXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50ID0gdGhpcy5pdGVtc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICBsZXQgaXRlbXNDb250YWluZXJXaWR0aCA9IDA7XHJcblxyXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RUYWIgPSB0aGlzLml0ZW1zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5baXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50IC0gMV0gYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGl0ZW1zQ29udGFpbmVyV2lkdGggPSBsYXN0VGFiLm9mZnNldExlZnQgKyBsYXN0VGFiLm9mZnNldFdpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zQ29udGFpbmVyV2lkdGg7XHJcbiAgICB9XHJcbn1cclxuXHJcbiJdfQ==