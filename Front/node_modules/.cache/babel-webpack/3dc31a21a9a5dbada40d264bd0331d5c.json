{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/user/OneDrive/\\u05DE\\u05E1\\u05DE\\u05DB\\u05D9\\u05DD/fullstack/ANGULAR/SECONDRESTORE/Front/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { environment } from 'src/environments/environment';\nimport OrderModel from '../models/order.model';\nimport { orderAddedAction, ordersDownloadedAction } from '../redux/order-state';\nimport store from '../redux/store';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./timezone.service\";\nexport class OrderService {\n  constructor(http, tz_helper) {\n    this.http = http;\n    this.tz_helper = tz_helper;\n  }\n\n  getOrderFile(fileName) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this.http.get(environment.ordersPDFUrl + fileName, {\n        responseType: 'blob'\n      }).toPromise();\n    })();\n  } // Get all orders: \n\n\n  getAllOrdersByOrderIdDesc() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (store.getState().orderState.orders.length === 0) {\n        const orders = yield _this2.http.get(environment.ordersUrl).toPromise();\n        store.dispatch(ordersDownloadedAction(orders));\n      }\n\n      return store.getState().orderState.orders;\n    })();\n  }\n\n  countOrders() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // NO REDUX NEEDED - because in real websites multiple users book orders in parallel, \n      // and every time i want to get the most updated information from server \n      const count = yield _this3.http.get(environment.ordersUrl + \"count\").toPromise();\n      return count;\n    })();\n  }\n\n  getFullyBookedDates() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // NO REDUX NEEDED - because in real websites multiple users book orders in parallel, \n      // and every time i want to get the most updated information from server to datepickeer\n      const count = yield _this4.http.get(environment.ordersUrl + \"count/dates\").toPromise();\n      return count;\n    })();\n  } // Get carts per user: --> never from redux!!! becoz i wan\n\n\n  getLastOrderByUser(uuid) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      // if (store.getState().orderState.orders.length === 0) {\n      const orders = yield _this5.http.get(environment.ordersUrl + \"user/\" + uuid).toPromise(); // Iterate over all employees and convert timezone to my local timezone\n\n      for (let order of orders) {\n        order.Date = _this5.tz_helper.convertTZ(order.Date).toString();\n      }\n\n      store.dispatch(ordersDownloadedAction(orders)); // }\n      // NEED TO UNDERSTAND IF THAT IS CORRECT\n      // const orders = store.getState().orderState.orders.filter(p => p.UserUUID === uuid);\n\n      return orders;\n    })();\n  } // // Get one employee: \n  // public async getOneEmployee(id: number) {\n  //     if (store.getState().employeesState.employees.length === 0) {\n  //         const employees = await this.http.get<EmployeeModel[]>(environment.employeesUrl).toPromise();\n  //         employees[0].BirthDate = this.tz_helper.convertTZ(employees[0].BirthDate).toString(); \n  //         store.dispatch(employeesDownloadedAction(employees));\n  //     }\n  //     const employee = store.getState().employeesState.employees.find(p => p.id === id);\n  //     return employee;\n  // }\n  // // Add order: \n\n\n  addOrder(order) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      console.log(order);\n      const myFormData = OrderModel.convertToFormData(order);\n      console.log(myFormData);\n      const addedOrder = yield _this6.http.post(environment.ordersUrl, myFormData).toPromise();\n      store.dispatch(orderAddedAction(addedOrder));\n      return addedOrder;\n    })();\n  }\n\n}\n\nOrderService.ɵfac = function OrderService_Factory(t) {\n  return new (t || OrderService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.TimezoneService));\n};\n\nOrderService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: OrderService,\n  factory: OrderService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["C:\\Users\\user\\OneDrive\\מסמכים\\fullstack\\ANGULAR\\SECONDRESTORE\\Front\\src\\app\\services\\order.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpClient, HttpParams } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { environment } from 'src/environments/environment';\nimport OrderModel from '../models/order.model';\nimport { orderAddedAction, ordersDownloadedAction } from '../redux/order-state';\nimport store from '../redux/store';\nimport { TimezoneService } from './timezone.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class OrderService {\n\n  constructor(private http: HttpClient, private tz_helper: TimezoneService) { }\n\n  public async getOrderFile(fileName: string) {\n        return await this.http.get(environment.ordersPDFUrl + fileName, { responseType: 'blob'}).toPromise();           \n  }\n\n    // Get all orders: \n    public async getAllOrdersByOrderIdDesc() {\n        if (store.getState().orderState.orders.length === 0) {\n            const orders = await this.http.get<OrderModel[]>(environment.ordersUrl).toPromise();           \n            store.dispatch(ordersDownloadedAction(orders));\n\n        }\n        return store.getState().orderState.orders;\n    }\n\n    public async countOrders() {\n      // NO REDUX NEEDED - because in real websites multiple users book orders in parallel, \n      // and every time i want to get the most updated information from server \n      const count = await this.http.get<[]>(environment.ordersUrl + \"count\").toPromise();\n      return count;\n    }\n\n    public async getFullyBookedDates() { \n      // NO REDUX NEEDED - because in real websites multiple users book orders in parallel, \n      // and every time i want to get the most updated information from server to datepickeer\n      const count = await this.http.get<[]>(environment.ordersUrl + \"count/dates\").toPromise();\n      return count;\n    }\n\n    // Get carts per user: --> never from redux!!! becoz i wan\n    public async getLastOrderByUser(uuid: string) { // NEVER FROM REDUX\n      // if (store.getState().orderState.orders.length === 0) {\n        const orders = await this.http.get<OrderModel[]>(environment.ordersUrl + \"user/\" + uuid).toPromise();\n          // Iterate over all employees and convert timezone to my local timezone\n        for (let order of orders) {\n          order.Date = this.tz_helper.convertTZ(order.Date).toString(); \n        }\n          store.dispatch(ordersDownloadedAction(orders));\n      // }\n          // NEED TO UNDERSTAND IF THAT IS CORRECT\n    // const orders = store.getState().orderState.orders.filter(p => p.UserUUID === uuid);\n    return orders;\n    }\n    \n    // // Get one employee: \n    // public async getOneEmployee(id: number) {\n    //     if (store.getState().employeesState.employees.length === 0) {\n    //         const employees = await this.http.get<EmployeeModel[]>(environment.employeesUrl).toPromise();\n    //         employees[0].BirthDate = this.tz_helper.convertTZ(employees[0].BirthDate).toString(); \n    //         store.dispatch(employeesDownloadedAction(employees));\n    //     }\n    //     const employee = store.getState().employeesState.employees.find(p => p.id === id);\n    //     return employee;\n    // }\n\n    // // Add order: \n    public async addOrder(order: OrderModel) {\n      console.log(order);\n        const myFormData: FormData = OrderModel.convertToFormData(order);\n        console.log(myFormData);\n        const addedOrder = await this.http.post<OrderModel>(environment.ordersUrl, myFormData).toPromise();\n        store.dispatch(orderAddedAction(addedOrder));\n        return addedOrder;\n    }\n\n    // // Update employee: \n    // public async updateEmployee(employee: EmployeeModel) {\n    //     const myFormData: FormData = EmployeeModel.convertToFormData(employee);\n    //     const updatedEmployee = await this.http.put<EmployeeModel>(environment.employeesUrl + employee.id, myFormData).toPromise();\n    //     store.dispatch(employeeUpdatedAction(updatedEmployee));\n    //     return updatedEmployee;\n    // }\n\n    // // Delete employee: \n    // public async deleteEmployee(id: number) {\n    //     await this.http.delete(environment.employeesUrl + id).toPromise();\n    //     store.dispatch(employeeDeletedAction(id));\n    // }\n\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}